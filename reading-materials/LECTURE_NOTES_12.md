# Локализация переменных в процедуре и «побочный» эффект

Подпрограмма любого уровня может иметь любое количество констант, переменных, типов и вложенных в нее подпрограмм низшего уровня. При этом считается, что все имена, описанные внутри подпрограммы, локализуются в ней, они как бы «невидимы» снаружи подпрограммы.

При входе в подпрограмму низшего уровня доступны не только объявленные в ней имена, но и все имена верхнего уровня. Получается, что снаружи подпрограммы не видны ее внутренние данные, но из подпрограммы можно видеть внешние (глобальные) объекты - те, которые описаны до данной процедуры.

Имена, локализованные в подпрограмме, могут совпадать с ранее объявленными глобальными именами. В этом случае считается, что локальное имя «закрывает» глобальное и делает его недоступным.

## Пример 1. Одноименные глобальные и локальные переменные.
```
var

     a : integer;  {глобальная переменная}



procedure Oy;  {процедура без параметров}

var a : integer;  {локальная переменная}

begin

a := 2; write (‘*’,a);  {работа с локальной переменной}

end;



begin {основная программа}

a := 5;

Oy; {вызов процедуры}

writeln('#',a);  {работа с глобальной переменной}

end.
```
Результат: *2#5



## Пример 2. «Побочный» эффект.
```
var

     b : integer;  {глобальная переменная}



procedure Oy;  {процедура без параметров}

var a : integer;  {локальная переменная}

begin

a := 2; b:=3; write (‘*’,a);  {изменение значения глобальной переменной}

end;



begin {основная программа}

b := 5;

Oy; {вызов процедуры + побочный эффект}

writeln('#',b);  {работа с глобальной переменной}

end.
```
Результат: *2#3

При побочном эффекте из анализа текста только основной программы невозможно установить факут изменения переменной b., поскольку это действия «спрятано» внутри функции Oy. Это обстоятельство существенно затрудняет понимание программы и тем самым снижает ее надежность. Но в некоторых случаях побочный эффект может оказаться весьма полезным для повышения эффективности программы.

Рекурсия

В программировании рекурсией называется вызов подпрограммы из тела самой подпрограммы.

## Пример 3. Рекурсивное вычисление факториала
```
type  MyInt=0..maxint;

. . . . . . . . . . . . . . . . . . .

function  Factorial (N: MyInt) : MyInt;

    begin

        if N=0  then  Factorial := 1

        else Factorial := N*Factorial(N-1)

    end;
```
## Пример 4. Вычисление факториала с помощью цикла
```
function  Factorial (N: MyInt) : MyInt;

var k,i: Myint;

    begin   k:=1;

        for i:=1 to N do k:=k*I;

        Factorial := k

    end;
```

Достоинство рекурсии – простота программирования, ясность и краткость кода.

Недостатки:

При многоуровневой рекурсии возможно переполнение стека, используемого для хранения копий локализованных переменных. Например, при вычислении Factorial(3) понадобится три копии переменных, а в случае Factorial (10) – десять значений.
Низкая производительность  (из-за повторных обращений к процедуре) по сравнению с обычным оператором цикла.


# Использование функциональных и процедурных параметров


При реализации некоторых подпрограмм возникает необходимость передачи имен процедур и функций в качестве входных параметров. В Паскале есть два соответствующих типа данных - процедурный и функциональный. Их описания размещают в разделе типов программы. Процедурный (функциональный) тип определяют в виде заголовка процедуры (функции) со списком формальных параметров, но без имени самой подпрограммы.

Например, можно описать процедурный тип следующим образом:

                 type ProcType = Procedure (x,y: real; var result: real);

Аналогично для функционального типа можно использовать описание:

                 type FuncType = Function (x,y: real): real);


Тогда заголовок процедуры, у которой формальными входными параметрами являются процедура MyProc и функция MyFun, имеющие типы соответственно ProcType и FuncType, может выглядеть так :

                 рrocedure  SomeProc(MyProc : ProcType; MyFun : FuncType; var res: real);  {здесь переменная res - выходной параметр процедуры SomeProc}

Замечание. При подстановке фактических процедурных или функциональных параметров в вызов внешней подпрограммы в Free Pascal (в отличие от Турбо Паскаля) перед именем данных параметров необходимо ставить оператор адреса @.

## Пример 5. Вычисление суммы и разности с помощью функциональных параметров
```
program funASparam;

type

MyFunction = function (a ,b :  real) : real; {функциональный тип}

function sum (a,b : real) : real; {вычисление суммы}
begin
sum:=a+b
end;

function diff (a,b : real) : real; {вычисление разности}
begin
diff:=a-b
end;

procedure calc (f : MyFunction;  x,y : real; var res : real); {используется функциональный параметр}
begin
res:=f(x,y)
end;

var x,y,res1,res2 : real;
begin

x:=10;
y:=20;

calc(@sum,x,y,res1);    {фактический параметр - процедура sum}
writeln(x,' + ',y,' = ',res1);
calc(@diff,x,y,res2);
writeln(x,' - ',y,' = ',res2)   {фактический параметр - процедура diff}

end.
```